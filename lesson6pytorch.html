<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" sizes="180x180" href="android-chrome-512x512.png">
    <title>Evaluating The Model: Pytorch Lesson 6</title>
    <style>
        #title {
            text-align: center;
            font-size: 64px;
        }
        body {
            font-family: Calibri;
        }
        #text {
            font-size: 200%;
            width: 95%;
            text-align: center;
            margin-left: auto;
            margin-right: auto;
        }
        .sub {
            font-size: 40px; 
            text-align:left;
        }
    </style>
</head>
<body>
    <h1><a href="https://kukuquack.github.io/home/" style="text-decoration: none; color: black;">Omar Zayed | Deep Learning</a></h1>
    <h1 id="title">Evaluating The Model: Pytorch Lesson 6</h1>
    <!-- <em><p style="text-align: center;">1 Sep, 2021</p></em> -->
    <div id="text">
        <p>Now that we have trained our model, it's time to evaluate it to see how well it performs.</p>
        <h1 class="sub">The Evaluation Function</h1>
        <img src="p7_1.PNG">
        <p>This is the function that we'll use for evaluation.</p>
        <p>On the first line, we have what's called a decorator. <code>torch.no_grad()</code> disables gradient calculation, which reduces memory consumption. We take the model and the validation set as parameters to the function, then we call the <code>.eval()</code> method, which tells the model that we'll start evaluating as the model behaves differently during training and evaluating (for example, it deactivates dropout layers).</p>
        <p>We then go through the validation set batch by batch using a for loop. We make the predictions, then we call <code>torch.max()</code> function. We call this function on the output and store the indexes in a variable called <code>preds</code>. We set <code>dim</code> to 1 because we want the maximum value in each prediction made for an image. We now have the actual predictions. We then call <code>torch.sum()</code> on <code>preds == labels</code> which is a tensor that contains Trues and Falses. True when the prediction is equal to the label and False otherwise. When we call <code>torch.sum()</code> on that, we get a tensor with the number of Trues found in the tensor. We call the <code>.item()</code> method to return a single number rather than a tensor, then divide that by the number of predictions, giving us the accuracy.</p>
        <h1 class="sub">Conclusion</h1>
        <p>Now we've evaluated our model, it's time to test the model on single pictures and do with it something useful.</p>
    </div>
</body>
</html>
